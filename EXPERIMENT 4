//Experiment No4 
//Implement binary search tree and perform following operations: 
//a. Insert (Handle insertion of duplicate entry) 
//b. Delete 
//c. Search 
//d. Display tree (Traversal) 
//e. Display - Depth of tree 
//f. Display - Mirror image
//g. Create a copy
// h. Display all parent nodes with their child nodes 
//i. Display leaf nodes 
//j. Display tree level wise i want code in python

// Binary Search Tree with requested operations
//from collections import deque
//from copy import deepcopy
//from typing import Optional, List, Tuple
//class Node:
    def __init__(self, key):
        self.key = key
        self.count = 1    # number of duplicate entries for this key
        self.left: Optional['Node'] = None
        self.right: Optional['Node'] = None
    def __repr__(self):
        if self.count > 1:
            return f"{self.key}({self.count})"
        return str(self.key)
class BinarySearchTree:
    def __init__(self):
        self.root: Optional[Node] = None

    # --------------- Insert (handle duplicates) ---------------
    def insert(self, key):
        def _insert(node: Optional[Node], key) -> Node:
            if node is None:
                return Node(key)
            if key == node.key:
                node.count += 1
            elif key < node.key:
                node.left = _insert(node.left, key)
            else:
                node.right = _insert(node.right, key)
            return node
        self.root = _insert(self.root, key)

    # --------------- Search ---------------
    def search(self, key) -> Optional[Node]:
        node = self.root
        while node:
            if key == node.key:
                return node
            elif key < node.key:
                node = node.left
            else:
                node = node.right
        return None

    # --------------- Delete (decrement count if duplicates) ---------------
    def delete(self, key):
        def _min_value_node(node: Node) -> Node:
            current = node
            while current.left:
                current = current.left
            return current

        def _delete(node: Optional[Node], key) -> Optional[Node]:
            if node is None:
                return None
            if key < node.key:
                node.left = _delete(node.left, key)
            elif key > node.key:
                node.right = _delete(node.right, key)
            else:
                # Found node
                if node.count > 1:
                    node.count -= 1
                    return node
                # node.count == 1 -> remove node
                if node.left is None:
                    return node.right
                elif node.right is None:
                    return node.left
                else:
                    # node with two children: replace with inorder successor
                    succ = _min_value_node(node.right)
                    node.key = succ.key
                    node.count = succ.count
                    # remove successor node(s) from right subtree (set succ's counts consumed)
                    # we must delete successor key succ.count times; but we moved succ.count into node,
                    # so we must remove all copies from the right subtree
                    node.right = _delete_all(node.right, succ.key)
            return node

        def _delete_all(node: Optional[Node], key) -> Optional[Node]:
            # delete all occurrences of key in subtree
            if node is None:
                return None
            if key < node.key:
                node.left = _delete_all(node.left, key)
            elif key > node.key:
                node.right = _delete_all(node.right, key)
            else:
                # remove this node (regardless of count)
                if node.left is None:
                    return node.right
                elif node.right is None:
                    return node.left
                else:
                    succ = _min_value_node(node.right)
                    node.key = succ.key
                    node.count = succ.count
                    node.right = _delete_all(node.right, succ.key)
            return node

        self.root = _delete(self.root, key)

    # --------------- Traversals (display tree) ---------------
    def inorder(self) -> List:
        res = []
        def _in(node):
            if node:
                _in(node.left)
                res.append((node.key, node.count))
                _in(node.right)
        _in(self.root)
        return res

    def preorder(self) -> List:
        res = []
        def _pre(node):
            if node:
                res.append((node.key, node.count))
                _pre(node.left)
                _pre(node.right)
        _pre(self.root)
        return res

    def postorder(self) -> List:
        res = []
        def _post(node):
            if node:
                _post(node.left)
                _post(node.right)
                res.append((node.key, node.count))
        _post(self.root)
        return res

    # Print traversal outputs in readable form
    def display_traversals(self):
        def fmt(lst):
            return " ".join(f"{k}" + (f"({c})" if c>1 else "") for k,c in lst)
        return {
            'inorder': fmt(self.inorder()),
            'preorder': fmt(self.preorder()),
            'postorder': fmt(self.postorder())
        }

    # --------------- Depth (height) ---------------
    def depth(self) -> int:
        def _depth(node: Optional[Node]) -> int:
            if node is None:
                return 0
            return 1 + max(_depth(node.left), _depth(node.right))
        return _depth(self.root)

    # --------------- Mirror image ---------------
    def mirror_inplace(self):
        """Convert tree to its mirror in-place."""
        def _mirror(node: Optional[Node]):
            if node:
                node.left, node.right = node.right, node.left
                _mirror(node.left)
                _mirror(node.right)
        _mirror(self.root)

    def mirror_copy(self) -> 'BinarySearchTree':
        """Return a new BST that is the mirror copy of current tree (structure mirrored)."""
        def _mirror_node(node: Optional[Node]) -> Optional[Node]:
            if node is None:
                return None
            new_node = Node(node.key)
            new_node.count = node.count
            # swap left/right when creating copy
            new_node.left = _mirror_node(node.right)
            new_node.right = _mirror_node(node.left)
            return new_node
        new_tree = BinarySearchTree()
        new_tree.root = _mirror_node(self.root)
        return new_tree

    # --------------- Create a (deep) copy ---------------
    def copy(self) -> 'BinarySearchTree':
        def _copy_node(node: Optional[Node]) -> Optional[Node]:
            if node is None:
                return None
            new_node = Node(node.key)
            new_node.count = node.count
            new_node.left = _copy_node(node.left)
            new_node.right = _copy_node(node.right)
            return new_node
        new_tree = BinarySearchTree()
        new_tree.root = _copy_node(self.root)
        return new_tree

    # --------------- Display all parent nodes with their child nodes ---------------
    def display_parents(self) -> List[Tuple]:
        """Return list of tuples (parent_key, left_child_key_or_None, right_child_key_or_None)."""
        res = []
        def _visit(node: Optional[Node]):
            if node:
                left = node.left.key if node.left else None
                right = node.right.key if node.right else None
                if left is not None or right is not None:
                    res.append((node.key, left, right))
                _visit(node.left)
                _visit(node.right)
        _visit(self.root)
        return res

    # --------------- Display leaf nodes ---------------
    def leaf_nodes(self) -> List[int]:
        leaves = []
        def _leaf(node: Optional[Node]):
            if node:
                if node.left is None and node.right is None:
                    leaves.append(node.key)
                _leaf(node.left)
                _leaf(node.right)
        _leaf(self.root)
        return leaves

    # --------------- Display tree level-wise (each level on new line) ---------------
    def level_order(self) -> List[List[Tuple]]:
        """Return list of levels; each level is list of tuples (key, count)."""
        levels = []
        if not self.root:
            return levels
        q = deque([self.root])
        while q:
            level_size = len(q)
            level = []
            for _ in range(level_size):
                node = q.popleft()
                level.append((node.key, node.count))
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            levels.append(level)
        return levels

    # Helper: pretty print level-order
    def print_level_order(self):
        levels = self.level_order()
        for i, level in enumerate(levels, start=1):
            row = " ".join(f"{k}" + (f"({c})" if c>1 else "") for k,c in level)
            print(f"Level {i}: {row}")

    # Utility: clear tree
    def clear(self):
        self.root = None

# ---------------- Example usage / demonstration ----------------
if __name__ == "__main__":
    bst = BinarySearchTree()
    data = [50, 30, 20, 40, 70, 60, 80, 70, 30]  # note duplicates: 70 and 30
    for x in data:
        bst.insert(x)

    print("Traversals:")
    for name, out in bst.display_traversals().items():
        print(f" {name}: {out}")

    print("\nDepth (height) of tree:", bst.depth())

    print("\nLevel-wise display:")
    bst.print_level_order()

    print("\nLeaf nodes:", bst.leaf_nodes())

    print("\nParent nodes with children:")
    for p, l, r in bst.display_parents():
        print(f" Parent {p}: left -> {l}, right -> {r}")

    # Search
    key = 70
    node = bst.search(key)
    print(f"\nSearch for {key}:", "Found" if node else "Not found", f"({node.count})" if node else "")

    # Delete examples (duplicate-aware)
    print("\nDeleting 70 (one occurrence).")
    bst.delete(70)
    print("Search for 70 after one delete:", bst.search(70))
    print("Deleting 70 (second occurrence).")
    bst.delete(70)
    print("Search for 70 after second delete:", bst.search(70))

    print("\nInorder after deletes:", bst.inorder())

    # Mirror copy
    mirrored = bst.mirror_copy()
    print("\nMirrored tree (level-wise):")
    mirrored.print_level_order()

    # Create a deep copy
    copy_tree = bst.copy()
    print("\nCopy tree (level-wise):")
    copy_tree.print_level_order()

    # In-place mirror (on the copy)
    print("\nMirroring the copy in-place...")
    copy_tree.mirror_inplace()
    print("Copy after in-place mirror:")
    copy_tree.print_level_order()


