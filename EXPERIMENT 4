
from collections import deque
from typing import Optional, List, Tuple, Deque

class Node:
    def __init__(self, key):
        self.key = key
        self.count = 1  # number of duplicate entries for this key
        self.left: Optional['Node'] = None
        self.right: Optional['Node'] = None

    def __repr__(self):
        return f"{self.key}({self.count})" if self.count > 1 else str(self.key)


class BinarySearchTree:
    def __init__(self):
        self.root: Optional['Node'] = None

    # --------------- Insert (handle duplicates) ---------------
    def insert(self, key):
        def _insert(node: Optional['Node'], key) -> 'Node':
            if node is None:
                return Node(key)
            if key == node.key:
                node.count += 1
            elif key < node.key:
                node.left = _insert(node.left, key)
            else:
                node.right = _insert(node.right, key)
            return node

        self.root = _insert(self.root, key)

    # --------------- Search ---------------
    def search(self, key) -> Optional['Node']:
        node = self.root
        while node:
            if key == node.key:
                return node
            node = node.left if key < node.key else node.right
        return None

    # --------------- Delete (decrement count if duplicates) ---------------
    def delete(self, key):
        def _min_value_node(node: 'Node') -> 'Node':
            current = node
            while current.left:
                current = current.left
            return current

        def _delete(node: Optional['Node'], key) -> Optional['Node']:
            if node is None:
                return None
            if key < node.key:
                node.left = _delete(node.left, key)
            elif key > node.key:
                node.right = _delete(node.right, key)
            else:
                # Found node
                if node.count > 1:
                    node.count -= 1
                    return node
                # node.count == 1 -> remove node
                if node.left is None:
                    return node.right
                if node.right is None:
                    return node.left
                # node with two children: replace with inorder successor
                succ = _min_value_node(node.right)
                node.key, node.count = succ.key, succ.count
                # remove all copies of successor key from right subtree
                node.right = _delete_all(node.right, succ.key)
            return node

        def _delete_all(node: Optional['Node'], key) -> Optional['Node']:
            # delete all occurrences of key in subtree
            if node is None:
                return None
            if key < node.key:
                node.left = _delete_all(node.left, key)
            elif key > node.key:
                node.right = _delete_all(node.right, key)
            else:
                # remove this node (regardless of count)
                if node.left is None:
                    return node.right
                if node.right is None:
                    return node.left
                succ = _min_value_node(node.right)
                node.key, node.count = succ.key, succ.count
                node.right = _delete_all(node.right, succ.key)
            return node

        self.root = _delete(self.root, key)

    # --------------- Traversals (display tree) ---------------
    def inorder(self) -> List[Tuple[int, int]]:
        res: List[Tuple[int, int]] = []

        def _in(node: Optional['Node']):
            if node:
                _in(node.left)
                res.append((node.key, node.count))
                _in(node.right)

        _in(self.root)
        return res

    def preorder(self) -> List[Tuple[int, int]]:
        res: List[Tuple[int, int]] = []

        def _pre(node: Optional['Node']):
            if node:
                res.append((node.key, node.count))
                _pre(node.left)
                _pre(node.right)

        _pre(self.root)
        return res

    def postorder(self) -> List[Tuple[int, int]]:
        res: List[Tuple[int, int]] = []

        def _post(node: Optional['Node']):
            if node:
                _post(node.left)
                _post(node.right)
                res.append((node.key, node.count))

        _post(self.root)
        return res

    # Print traversal outputs in readable form
    def display_traversals(self):
        def fmt(lst: List[Tuple[int, int]]) -> str:
            return " ".join(f"{k}" + (f"({c})" if c > 1 else "") for k, c in lst)

        return {
            'inorder': fmt(self.inorder()),
            'preorder': fmt(self.preorder()),
            'postorder': fmt(self.postorder())
        }

    # --------------- Depth (height) ---------------
    def depth(self) -> int:
        def _depth(node: Optional['Node']) -> int:
            if node is None:
                return 0
            return 1 + max(_depth(node.left), _depth(node.right))

        return _depth(self.root)

    # --------------- Mirror image ---------------
    def mirror_inplace(self):
        """Convert tree to its mirror in-place."""
        def _mirror(node: Optional['Node']):
            if node:
                node.left, node.right = node.right, node.left
                _mirror(node.left)
                _mirror(node.right)

        _mirror(self.root)

    def mirror_copy(self) -> 'BinarySearchTree':
        """Return a new BST that is the mirror copy of current tree (structure mirrored)."""
        def _mirror_node(node: Optional['Node']) -> Optional['Node']:
            if node is None:
                return None
            new_node = Node(node.key)
            new_node.count = node.count
            new_node.left = _mirror_node(node.right)
            new_node.right = _mirror_node(node.left)
            return new_node

        new_tree = BinarySearchTree()
        new_tree.root = _mirror_node(self.root)
        return new_tree

    # --------------- Create a (deep) copy ---------------
    def copy(self) -> 'BinarySearchTree':
        def _copy_node(node: Optional['Node']) -> Optional['Node']:
            if node is None:
                return None
            new_node = Node(node.key)
            new_node.count = node.count
            new_node.left = _copy_node(node.left)
            new_node.right = _copy_node(node.right)
            return new_node

        new_tree = BinarySearchTree()
        new_tree.root = _copy_node(self.root)
        return new_tree

    # --------------- Display all parent nodes with their child nodes ---------------
    def display_parents(self) -> List[Tuple[int, Optional[int], Optional[int]]]:
        """Return list of tuples (parent_key, left_child_key_or_None, right_child_key_or_None)."""
        res: List[Tuple[int, Optional[int], Optional[int]]] = []

        def _visit(node: Optional['Node']):
            if node:
                left = node.left.key if node.left else None
                right = node.right.key if node.right else None
                if left is not None or right is not None:
                    res.append((node.key, left, right))
                _visit(node.left)
                _visit(node.right)

        _visit(self.root)
        return res

    # --------------- Display leaf nodes ---------------
    def leaf_nodes(self) -> List[int]:
        leaves: List[int] = []

        def _leaf(node: Optional['Node']):
            if node:
                if node.left is None and node.right is None:
                    leaves.append(node.key)
                _leaf(node.left)
                _leaf(node.right)

        _leaf(self.root)
        return leaves

    # --------------- Display tree level-wise (each level on new line) ---------------
    def level_order(self) -> List[List[Tuple[int, int]]]:
        """Return list of levels; each level is list of tuples (key, count)."""
        levels: List[List[Tuple[int, int]]] = []
        if not self.root:
            return levels
        q: Deque['Node'] = deque([self.root])
        while q:
            level_size = len(q)
            level: List[Tuple[int, int]] = []
            for _ in range(level_size):
                node = q.popleft()
                level.append((node.key, node.count))
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            levels.append(level)
        return levels

    # Helper: pretty print level-order
    def print_level_order(self):
        levels = self.level_order()
        for i, level in enumerate(levels, start=1):
            row = " ".join(f"{k}" + (f"({c})" if c > 1 else "") for k, c in level)
            print(f"Level {i}: {row}")

    # Utility: clear tree
    def clear(self):
        self.root = None


# ---------------- Example usage / demonstration ----------------
if __name__ == "__main__":
    bst = BinarySearchTree()
    data = [50, 30, 20, 40, 70, 60, 80, 70, 30]  # note duplicates: 70 and 30
    for x in data:
        bst.insert(x)

    print("Traversals:")
    for name, out in bst.display_traversals().items():
        print(f" {name}: {out}")

    print("\nDepth (height) of tree:", bst.depth())

    print("\nLevel-wise display:")
    bst.print_level_order()

    print("\nLeaf nodes:", bst.leaf_nodes())

    print("\nParent nodes with children:")
    for p, l, r in bst.display_parents():
        print(f" Parent {p}: left -> {l}, right -> {r}")

    # Search
    key = 70
    node = bst.search(key)
    print(f"\nSearch for {key}:", "Found" if node else "Not found", f"({node.count})" if node else "")

    # Delete examples (duplicate-aware)
    print("\nDeleting 70 (one occurrence).")
    bst.delete(70)
    print("Search for 70 after one delete:", bst.search(70))
    print("Deleting 70 (second occurrence).")
    bst.delete(70)
    print("Search for 70 after second delete:", bst.search(70))

    print("\nInorder after deletes:", bst.inorder())

    # Mirror copy
    mirrored = bst.mirror_copy()
    print("\nMirrored tree (level-wise):")
    mirrored.print_level_order()

    # Create a deep copy
    copy_tree = bst.copy()
    print("\nCopy tree (level-wise):")
    copy_tree.print_level_order()

    # In-place mirror (on the copy)
    print("\nMirroring the copy in-place...")
    copy_tree.mirror_inplace()
    print("Copy after in-place mirror:")
    print()
    copy_tree.print_level_order()
