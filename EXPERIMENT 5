class Graph:
    def __init__(self, vertices):
        self.V = vertices
        self.graph = []  # For Kruskal (Edge List)
        self.adj_matrix = [[0 for _ in range(vertices)] for _ in range(vertices)]
        self.node_names = []

    def add_node_names(self, names):
        """Assign human-readable names to vertices."""
        self.node_names = names

    def add_edge(self, u, v, w):
        """Add edge between node u and v with weight w"""
        self.graph.append([u, v, w])
        self.adj_matrix[u][v] = w
        self.adj_matrix[v][u] = w

    def print_adj_matrix(self):
        """Display adjacency matrix"""
        print("\nAdjacency Matrix:")
        print("     " + "  ".join(f"{name[:3]}" for name in self.node_names))
        for i, row in enumerate(self.adj_matrix):
            print(f"{self.node_names[i][:3]}:  " + "  ".join(f"{val:2}" for val in row))

    def adjacency_list(self):
        """Convert adjacency matrix to adjacency list"""
        adj_list = {self.node_names[i]: [] for i in range(self.V)}
        for i in range(self.V):
            for j in range(self.V):
                if self.adj_matrix[i][j] != 0:
                    adj_list[self.node_names[i]].append((self.node_names[j], self.adj_matrix[i][j]))
        return adj_list

    # ---------- Kruskalâ€™s Algorithm ----------
    def find(self, parent, i):
        if parent[i] != i:
            parent[i] = self.find(parent, parent[i])
        return parent[i]

    def union(self, parent, rank, x, y):
        xroot = self.find(parent, x)
        yroot = self.find(parent, y)
        if rank[xroot] < rank[yroot]:
            parent[xroot] = yroot
        elif rank[xroot] > rank[yroot]:
            parent[yroot] = xroot
        else:
            parent[yroot] = xroot
            rank[xroot] += 1

    def kruskal_mst(self):
        result = []  # Store MST edges
        i, e = 0, 0  # i: edge counter, e: result counter
        self.graph = sorted(self.graph, key=lambda item: item[2])  # sort edges by weight

        parent = []
        rank = []
        for node in range(self.V):
            parent.append(node)
            rank.append(0)

        while e < self.V - 1 and i < len(self.graph):
            u, v, w = self.graph[i]
            i += 1
            x = self.find(parent, u)
            y = self.find(parent, v)
            if x != y:
                e += 1
                result.append((u, v, w))
                self.union(parent, rank, x, y)

        total_weight = sum(w for _, _, w in result)
        print("\nðŸ“˜ Kruskalâ€™s Minimum Spanning Tree:")
        for u, v, weight in result:
            print(f"  {self.node_names[u]} -- {self.node_names[v]}  ({weight} m)")
        print(f"âž¡ï¸ Total Minimum Distance: {total_weight} m")

    # ---------- Primâ€™s Algorithm ----------
    def prim_mst(self):
        selected = [False] * self.V
        no_edge = 0
        selected[0] = True
        print("\nðŸ“— Primâ€™s Minimum Spanning Tree:")
        total_weight = 0

        while no_edge < self.V - 1:
            minimum = float('inf')
            x = 0
            y = 0
            for i in range(self.V):
                if selected[i]:
                    for j in range(self.V):
                        if (not selected[j]) and self.adj_matrix[i][j]:
                            if minimum > self.adj_matrix[i][j]:
                                minimum = self.adj_matrix[i][j]
                                x = i
                                y = j
            print(f"  {self.node_names[x]} -- {self.node_names[y]}  ({self.adj_matrix[x][y]} m)")
            total_weight += self.adj_matrix[x][y]
            selected[y] = True
            no_edge += 1
        print(f"âž¡ï¸ Total Minimum Distance: {total_weight} m")


# -------------------------------------------
# Example: College Campus Graph
# -------------------------------------------

# Define departments/buildings
names = ["Admin", "CS Dept", "AIML Dept", "Library", "Canteen", "Workshop"]

# Create graph
g = Graph(len(names))
g.add_node_names(names)

# Add weighted edges (distances in meters)
g.add_edge(0, 1, 10)  # Admin - CS
g.add_edge(0, 2, 15)  # Admin - AIML
g.add_edge(1, 3, 12)  # CS - Library
g.add_edge(2, 3, 13)  # AIML - Library
g.add_edge(1, 4, 15)  # CS - Canteen
g.add_edge(3, 5, 5)   # Library - Workshop
g.add_edge(4, 5, 10)  # Canteen - Workshop

# Display representations
g.print_adj_matrix()

print("\nAdjacency List:")
for k, v in g.adjacency_list().items():
    print(f" {k} -> {v}")

# Run MST Algorithms
g.kruskal_mst()
g.prim_mst()


