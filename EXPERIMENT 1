//Searching and Sorting Exp1
//Design a program to maintain a student database that performs the following tasks:
//1. Add and store student details (ID, Name, CGPA) using dynamically allocated memory.
//2. Expand the student list using realloc() as new entries are added.
//3. Implement Linear Search and Binary Search to find student records by ID.
//4. Implement at least two Sorting Algorithms (Bubble Sort, Selection Sort, or Insertion Sort) //to sort student records by:
//a. Name (Alphabetically)
//b. CGPA (Ascending/Descending)
//5.Analyze and compare the performance of search operations before and after sorting.


/*
------------------------------------------------------------
DSA Experiment: Searching and Sorting on Student Database
------------------------------------------------------------
Features:
1. Dynamically allocate memory for student records
2. Use realloc() to expand list as needed
3. Linear Search & Binary Search (by ID)
4. Sorting:
   a. By Name (Alphabetically)
   b. By CGPA (Ascending/Descending)
5. Compare performance before and after sorting
------------------------------------------------------------
Author: [Your Name]
Compiler: DEV C++ / GCC
------------------------------------------------------------
*/

#include <bits/stdc++.h>
using namespace std;

struct Student {
    int id;
    string name;
    float cgpa;
};

void addStudent(vector<Student>& a) {
    Student s{};
    cout << "Enter Student ID: ";
    if (!(cin >> s.id)) { cin.clear(); cin.ignore(numeric_limits<streamsize>::max(), '\n'); cout << "Invalid ID.\n"; return; }
    cin.ignore(numeric_limits<streamsize>::max(), '\n');
    cout << "Enter Student Name: ";
    getline(cin, s.name);
    cout << "Enter CGPA: ";
    if (!(cin >> s.cgpa)) { cin.clear(); cin.ignore(numeric_limits<streamsize>::max(), '\n'); cout << "Invalid CGPA.\n"; return; }
    a.push_back(std::move(s));
    cout << "Student added successfully!\n";
}

void displayStudents(const vector<Student>& a) {
    if (a.empty()) { cout << "No student records available.\n"; return; }
    cout << "\n===== Student Records =====\n";
    for (const auto& s : a)
        cout << "ID: " << s.id << "\tName: " << s.name << "\tCGPA: " << s.cgpa << '\n';
}

int linearSearch(const vector<Student>& a, int id) {
    for (size_t i = 0; i < a.size(); ++i) if (a[i].id == id) return static_cast<int>(i);
    return -1;
}

int binarySearchById(const vector<Student>& a, int id) {
    int lo = 0, hi = static_cast<int>(a.size()) - 1;
    while (lo <= hi) {
        int mid = lo + (hi - lo) / 2;
        if (a[mid].id == id) return mid;
        (a[mid].id < id) ? lo = mid + 1 : hi = mid - 1;
    }
    return -1;
}

void bubbleSortByName(vector<Student>& a) {
    for (int i = 0; i < (int)a.size() - 1; ++i)
        for (int j = 0; j < (int)a.size() - i - 1; ++j)
            if (a[j].name > a[j + 1].name) swap(a[j], a[j + 1]);
}

void selectionSortByCGPA(vector<Student>& a, bool asc) {
    for (int i = 0; i < (int)a.size() - 1; ++i) {
        int k = i;
        for (int j = i + 1; j < (int)a.size(); ++j)
            if (asc ? (a[j].cgpa < a[k].cgpa) : (a[j].cgpa > a[k].cgpa)) k = j;
        if (k != i) swap(a[i], a[k]);
    }
}

void sortById(vector<Student>& a) {
    sort(a.begin(), a.end(), [](const Student& x, const Student& y){ return x.id < y.id; });
}

void analyzeSearchPerformance(const vector<Student>& a) {
    if (a.empty()) { cout << "Add students first!\n"; return; }
    int id; cout << "Enter ID to search for performance analysis: ";
    if (!(cin >> id)) { cin.clear(); cin.ignore(numeric_limits<streamsize>::max(), '\n'); cout << "Invalid ID.\n"; return; }

    cout << "\n-- Linear Search (Unsorted snapshot) --\n";
    int p1 = linearSearch(a, id);
    if (p1 != -1) cout << "Found: " << a[p1].name << "\n";
    else cout << "Not found.\n";

    cout << "\n-- Binary Search (Sorted by ID, copy) --\n";
    vector<Student> b = a; // preserve original
    sortById(b);
    int p2 = binarySearchById(b, id);
    if (p2 != -1) cout << "Found: " << b[p2].name << "\n";
    else cout << "Not found.\n";
}

int main() {
    vector<Student> students;
    int choice;
    do {
        cout << "\n====== STUDENT DATABASE MENU ======"
             << "\n1. Add Student"
             << "\n2. Display All Students"
             << "\n3. Linear Search by ID"
             << "\n4. Sort by Name (Alphabetically - Bubble Sort)"
             << "\n5. Sort by CGPA (Selection Sort)"
             << "\n6. Binary Search by ID (Sort by ID first)"
             << "\n7. Analyze Search Performance"
             << "\n0. Exit"
             << "\nEnter your choice: ";
        if (!(cin >> choice)) { cin.clear(); cin.ignore(numeric_limits<streamsize>::max(), '\n'); cout << "Invalid choice.\n"; continue; }

        switch (choice) {
            case 1: addStudent(students); break;
            case 2: displayStudents(students); break;
            case 3: {
                int id; cout << "Enter Student ID to Search: "; 
                if (!(cin >> id)) { cin.clear(); cin.ignore(numeric_limits<streamsize>::max(), '\n'); cout << "Invalid ID.\n"; break; }
                int p = linearSearch(students, id);
                if (p != -1) cout << "Found: " << students[p].name << " (CGPA: " << students[p].cgpa << ")\n";
                else cout << "Student not found!\n";
            } break;
            case 4: bubbleSortByName(students); cout << "Students sorted alphabetically by name.\n"; break;
            case 5: {
                int order; cout << "1. Ascending\n2. Descending\nChoose order: ";
                if (!(cin >> order)) { cin.clear(); cin.ignore(numeric_limits<streamsize>::max(), '\n'); cout << "Invalid order.\n"; break; }
                selectionSortByCGPA(students, order == 1);
                cout << "Students sorted by CGPA.\n";
            } break;
            case 6: {
                if (students.empty()) { cout << "No students.\n"; break; }
                sortById(students);
                int id; cout << "Enter Student ID to search (Binary Search): ";
                if (!(cin >> id)) { cin.clear(); cin.ignore(numeric_limits<streamsize>::max(), '\n'); cout << "Invalid ID.\n"; break; }
                int p = binarySearchById(students, id);
                if (p != -1) cout << "Found: " << students[p].name << " (CGPA: " << students[p].cgpa << ")\n";
                else cout << "Student not found!\n";
            } break;
            case 7: analyzeSearchPerformance(students); break;
            case 0: cout << "Exiting program...\n"; break;
            default: cout << "Invalid choice!\n";
        }
    } while (choice != 0);
    return 0;
}
