// Experiment No 2 Stack 
//Implement stack as an abstract data type using singly linked list and use this ADT for
//conversion of infix expression to postfix, prefix
#include <iostream>
#include <string>
#include <algorithm>
#include <cctype>   // <-- add this
using namespace std;

struct Node { char data; Node* next; };
class Stack {
    Node* top;
public:
    Stack(): top(NULL) {}
    void push(char x){ Node* t = new Node; t->data=x; t->next=top; top=t; }
    char pop(){
        if (isEmpty()){ cout<<"Stack Underflow\n"; return '\0'; }
        Node* t=top; char v=t->data; top=top->next; delete t; return v;
    }
    char peek(){ return isEmpty() ? '\0' : top->data; }
    bool isEmpty(){ return top==NULL; }
};

bool isOperator(char c){ return c=='+'||c=='-'||c=='*'||c=='/'||c=='^'; }
int precedence(char c){
    if (c=='^') return 3;
    if (c=='*'||c=='/') return 2;
    if (c=='+'||c=='-') return 1;
    return -1;
}
bool isLeftAssoc(char c){ return c!='^'; } // ^ is right-associative

string infixToPostfix(const string& infix){
    Stack s; string out;
    for(char c: infix){
        if (std::isspace(static_cast<unsigned char>(c))) continue; // allow spaces
        if (std::isalnum(static_cast<unsigned char>(c))){
            out += c;
        } else if (c=='('){
            s.push(c);
        } else if (c==')'){
            while (!s.isEmpty() && s.peek()!='(') out += s.pop();
            if (s.isEmpty()){ cout<<"Mismatched parentheses\n"; return out; }
            s.pop(); // pop '('
        } else if (isOperator(c)){
            while (!s.isEmpty() && isOperator(s.peek()) &&
                   (precedence(s.peek()) > precedence(c) ||
                   (precedence(s.peek()) == precedence(c) && isLeftAssoc(c)))){
                out += s.pop();
            }
            s.push(c);
        }
    }
    while (!s.isEmpty()){
        if (s.peek()=='('||s.peek()==')'){ cout<<"Mismatched parentheses\n"; s.pop(); continue; }
        out += s.pop();
    }
    return out;
}

string reverseInfix(string exp){
    reverse(exp.begin(), exp.end());
    for (size_t i=0;i<exp.size();++i){
        if (exp[i]=='(') exp[i]=')';
        else if (exp[i]==')') exp[i]='(';
    }
    return exp;
}
string infixToPrefix(const string& infix){
    string r = reverseInfix(infix);
    string post = infixToPostfix(r);
    reverse(post.begin(), post.end());
    return post;
}

int main(){
    string infix;
    cout << "Enter Infix Expression: ";
    getline(cin, infix); // supports spaces

    string postfix = infixToPostfix(infix);
    string prefix  = infixToPrefix(infix);

    cout << "\nInfix Expression: "  << infix
         << "\nPostfix Expression: " << postfix
         << "\nPrefix  Expression: " << prefix << endl;
    return 0;
}
